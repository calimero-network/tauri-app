name: Build macOS

on:
  workflow_call:
    inputs:
      version:
        description: "Version number (e.g., 1.0.0)"
        required: true
        type: string
    secrets:
      # Apple code signing (required for signed releases)
      APPLE_CERTIFICATE:
        required: true
      APPLE_CERTIFICATE_PASSWORD:
        required: true
      APPLE_SIGNING_IDENTITY:
        required: true
      APPLE_TEAM_ID:
        required: true
      # Apple notarization (required for distribution)
      APPLE_ID:
        required: true
      APPLE_APP_SPECIFIC_PASSWORD:
        required: true
      # Tauri updater signing (required for auto-updates)
      TAURI_PRIVATE_KEY:
        required: true
      TAURI_KEY_PASSWORD:
        required: false
      TAURI_PUBLIC_KEY:
        required: true
    outputs:
      artifact-name:
        description: "Name of the uploaded artifact"
        value: ${{ jobs.build.outputs.artifact-name }}
  pull_request:
    branches:
      - master
      - main

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: Build macOS Universal
    runs-on: macos-latest
    outputs:
      artifact-name: macos-build

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine build mode
        id: build-mode
        run: |
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "mode=validation" >> $GITHUB_OUTPUT
            echo "version=0.0.0-dev" >> $GITHUB_OUTPUT
          else
            echo "mode=release" >> $GITHUB_OUTPUT
            echo "version=${{ inputs.version }}" >> $GITHUB_OUTPUT
          fi

      - name: Validate required secrets for release
        if: steps.build-mode.outputs.mode == 'release'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_PUBLIC_KEY: ${{ secrets.TAURI_PUBLIC_KEY }}
        run: |
          MISSING=""
          [ -z "$APPLE_CERTIFICATE" ] && MISSING="$MISSING APPLE_CERTIFICATE"
          [ -z "$APPLE_SIGNING_IDENTITY" ] && MISSING="$MISSING APPLE_SIGNING_IDENTITY"
          [ -z "$APPLE_TEAM_ID" ] && MISSING="$MISSING APPLE_TEAM_ID"
          [ -z "$APPLE_ID" ] && MISSING="$MISSING APPLE_ID"
          [ -z "$APPLE_APP_SPECIFIC_PASSWORD" ] && MISSING="$MISSING APPLE_APP_SPECIFIC_PASSWORD"
          [ -z "$TAURI_PRIVATE_KEY" ] && MISSING="$MISSING TAURI_PRIVATE_KEY"
          [ -z "$TAURI_PUBLIC_KEY" ] && MISSING="$MISSING TAURI_PUBLIC_KEY"

          if [ -n "$MISSING" ]; then
            echo "Error: Missing required secrets for signed release:$MISSING"
            echo "All releases must be signed. Set up the required secrets before releasing."
            exit 1
          fi
          echo "All required secrets are configured"

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "pnpm"

      - name: Get pnpm store directory
        id: get-pnpm-store
        shell: bash
        run: |
          STORE_PATH=$(pnpm store path --silent || echo "$HOME/.pnpm-store")
          echo "path=$STORE_PATH" >> $GITHUB_OUTPUT

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ steps.get-pnpm-store.outputs.path }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: aarch64-apple-darwin,x86_64-apple-darwin

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: apps/desktop/src-tauri

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build workspace packages
        run: |
          pnpm build:mero-js
          pnpm build:mero-react

      - name: Generate icons
        working-directory: apps/desktop
        run: pnpm tauri icon src-tauri/icons/icon.png

      - name: Update version in tauri.conf.json
        if: steps.build-mode.outputs.mode == 'release'
        run: |
          VERSION="${{ steps.build-mode.outputs.version }}"
          cd apps/desktop/src-tauri
          node -e "
            const fs = require('fs');
            const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));
            config.package.version = '$VERSION';
            fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
          "

      - name: Inject updater pubkey from secret
        if: steps.build-mode.outputs.mode == 'release'
        env:
          TAURI_PUBLIC_KEY: ${{ secrets.TAURI_PUBLIC_KEY }}
        run: |
          if [ -n "$TAURI_PUBLIC_KEY" ]; then
            cd apps/desktop/src-tauri
            node -e "
              const fs = require('fs');
              const config = JSON.parse(fs.readFileSync('tauri.conf.json', 'utf8'));
              config.tauri.updater.pubkey = process.env.TAURI_PUBLIC_KEY;
              fs.writeFileSync('tauri.conf.json', JSON.stringify(config, null, 2));
            "
            echo "Injected TAURI_PUBLIC_KEY into tauri.conf.json"
          else
            echo "No TAURI_PUBLIC_KEY provided, using default pubkey"
          fi

      - name: Import Apple codesign cert
        if: steps.build-mode.outputs.mode == 'release'
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          if [ -z "$APPLE_CERTIFICATE" ]; then
            echo "No Apple certificate provided, skipping code signing setup"
            exit 0
          fi

          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12

          security create-keychain -p "" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain
          security unlock-keychain -p "" build.keychain
          security default-keychain -s build.keychain

          security import certificate.p12 \
            -k build.keychain \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/productbuild

          security set-key-partition-list -S apple-tool:,apple: -s -k "" build.keychain

          rm -f certificate.p12

      - name: Build Tauri app for macOS (Universal) - Release
        if: steps.build-mode.outputs.mode == 'release'
        working-directory: apps/desktop
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        id: build-app-release
        run: |
          if [ -n "$APPLE_SIGNING_IDENTITY" ]; then
            echo "is_signed=true" >> $GITHUB_OUTPUT
          else
            echo "is_signed=false" >> $GITHUB_OUTPUT
          fi

          pnpm tauri build --target universal-apple-darwin

      - name: Build Tauri app for macOS (Universal) - Validation
        if: steps.build-mode.outputs.mode == 'validation'
        working-directory: apps/desktop
        id: build-app-validation
        env:
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: |
          echo "is_signed=false" >> $GITHUB_OUTPUT
          pnpm tauri build --target universal-apple-darwin

      - name: Sign embedded binaries
        if: steps.build-mode.outputs.mode == 'release' && steps.build-app-release.outputs.is_signed == 'true'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
        run: |
          if [ -z "$APPLE_SIGNING_IDENTITY" ]; then
            echo "No signing identity provided, skipping embedded binary signing"
            exit 0
          fi

          # Find the .app bundle
          APP_BUNDLE=$(find apps/desktop/src-tauri/target/universal-apple-darwin/release/bundle/macos -name "*.app" -type d | head -1)
          
          if [ -z "$APP_BUNDLE" ]; then
            echo "No .app bundle found"
            exit 1
          fi

          echo "Found app bundle: $APP_BUNDLE"

          # Sign the merod binary if it exists
          MEROD_BINARY="$APP_BUNDLE/Contents/Resources/merod/merod"
          
          if [ -f "$MEROD_BINARY" ]; then
            echo "Signing merod binary: $MEROD_BINARY"
            codesign --force --deep --sign "$APPLE_SIGNING_IDENTITY" \
              --options runtime \
              --timestamp \
              "$MEROD_BINARY"
            
            # Verify the signature
            codesign --verify --verbose "$MEROD_BINARY" || {
              echo "Failed to verify merod binary signature"
              exit 1
            }
            echo "Successfully signed merod binary"
          else
            echo "Warning: merod binary not found at $MEROD_BINARY"
          fi

          # Re-sign the entire app bundle to update the code signature
          # This is necessary because signing embedded binaries invalidates the app's signature
          echo "Re-signing app bundle..."
          codesign --force --deep --sign "$APPLE_SIGNING_IDENTITY" \
            --options runtime \
            --timestamp \
            --entitlements "$APP_BUNDLE/Contents/Resources/entitlements.plist" \
            "$APP_BUNDLE" 2>/dev/null || \
          codesign --force --deep --sign "$APPLE_SIGNING_IDENTITY" \
            --options runtime \
            --timestamp \
            "$APP_BUNDLE"

          # Verify the app bundle signature
          codesign --verify --verbose "$APP_BUNDLE" || {
            echo "Failed to verify app bundle signature"
            exit 1
          }
          
          # Check for any unsigned binaries
          echo "Checking for unsigned binaries in app bundle..."
          UNSIGNED=$(find "$APP_BUNDLE" -type f -exec sh -c 'codesign --verify "$1" 2>&1 | grep -q "code object is not signed" && echo "$1"' _ {} \;)
          
          if [ -n "$UNSIGNED" ]; then
            echo "Error: Found unsigned binaries:"
            echo "$UNSIGNED"
            exit 1
          fi
          
          echo "All binaries in app bundle are signed"

      - name: Recreate DMG and updater archive after signing
        if: steps.build-mode.outputs.mode == 'release' && steps.build-app-release.outputs.is_signed == 'true'
        env:
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
          TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
        run: |
          if [ -z "$APPLE_SIGNING_IDENTITY" ]; then
            echo "No signing identity provided, skipping archive recreation"
            exit 0
          fi

          # Find the signed .app bundle
          APP_BUNDLE=$(find apps/desktop/src-tauri/target/universal-apple-darwin/release/bundle/macos -name "*.app" -type d | head -1)
          
          if [ -z "$APP_BUNDLE" ]; then
            echo "No .app bundle found"
            exit 1
          fi

          APP_NAME=$(basename "$APP_BUNDLE" .app)
          BUNDLE_DIR=$(dirname "$APP_BUNDLE")
          TARGET_DIR=$(dirname "$BUNDLE_DIR")
          DMG_DIR="$BUNDLE_DIR/dmg"
          
          # Save original working directory for later use
          ORIGINAL_DIR="$(pwd)"

          echo "Recreating DMG and updater archive from signed app bundle: $APP_BUNDLE"

          # Find and remove old DMG and .app.tar.gz files
          echo "Removing old DMG and archive files..."
          find "$TARGET_DIR" -name "*.dmg" -delete
          find "$TARGET_DIR" -name "*.app.tar.gz" -delete
          find "$TARGET_DIR" -name "*.app.tar.gz.sig" -delete

          # Recreate DMG from signed .app bundle
          # Tauri creates DMG with format: "Product Name_version_universal.dmg"
          # We'll use the same format but need to get the version
          VERSION="${{ steps.build-mode.outputs.version }}"
          DMG_NAME="${APP_NAME}_${VERSION}_universal.dmg"
          DMG_PATH="$DMG_DIR/$DMG_NAME"
          
          mkdir -p "$DMG_DIR"
          
          # Create DMG using hdiutil
          hdiutil create -volname "$APP_NAME" \
            -srcfolder "$APP_BUNDLE" \
            -ov -format UDZO \
            "$DMG_PATH" || {
            echo "Failed to create DMG"
            exit 1
          }

          # Sign the DMG
          echo "Signing DMG..."
          codesign --force --sign "$APPLE_SIGNING_IDENTITY" \
            --options runtime \
            --timestamp \
            "$DMG_PATH" || {
            echo "Failed to sign DMG"
            exit 1
          }

          # Verify DMG signature
          codesign --verify --verbose "$DMG_PATH" || {
            echo "Failed to verify DMG signature"
            exit 1
          }

          echo "Successfully created and signed DMG: $DMG_PATH"

          # Recreate .app.tar.gz for auto-updater
          echo "Creating new .app.tar.gz archive from signed app bundle..."
          TAR_NAME="${APP_NAME}_${VERSION}_universal.app.tar.gz"
          TAR_PATH="$BUNDLE_DIR/$TAR_NAME"
          
          cd "$BUNDLE_DIR"
          tar -czf "$TAR_PATH" -C "$(dirname "$APP_BUNDLE")" "$(basename "$APP_BUNDLE")" || {
            echo "Failed to create .app.tar.gz"
            exit 1
          }

          echo "Successfully created updater archive: $TAR_PATH"

          # Regenerate signature file for the updater archive
          # Tauri's build process creates this, but we need to recreate it after rebuilding the archive
          if [ -n "$TAURI_PRIVATE_KEY" ]; then
            echo "Regenerating signature for updater archive..."
            # Return to original directory before changing to apps/desktop
            cd "$ORIGINAL_DIR/apps/desktop"
            # Use absolute path for the tar file
            ABS_TAR_PATH="$(cd "$BUNDLE_DIR" && pwd)/$(basename "$TAR_PATH")"
            pnpm tauri signer sign "$ABS_TAR_PATH" || {
              echo "Warning: Failed to regenerate signature file (this may be expected if signer is not configured)"
            }
          else
            echo "TAURI_PRIVATE_KEY not available, skipping signature regeneration"
          fi

      - name: Cleanup keychain
        if: always() && steps.build-mode.outputs.mode == 'release'
        run: security delete-keychain build.keychain 2>/dev/null || true

      - name: Notarize DMG
        if: steps.build-mode.outputs.mode == 'release' && steps.build-app-release.outputs.is_signed == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "$APPLE_ID" ] || [ -z "$APPLE_APP_SPECIFIC_PASSWORD" ]; then
            echo "Notarization credentials not provided, skipping"
            exit 0
          fi

          DMG_FILE=$(find apps/desktop/src-tauri/target -name "*.dmg" 2>/dev/null | head -1)

          if [ -z "$DMG_FILE" ]; then
            echo "No DMG found to notarize"
            exit 0
          fi

          xcrun notarytool submit "$DMG_FILE" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m

          xcrun stapler staple "$DMG_FILE"

      - name: Verify build outputs
        if: steps.build-mode.outputs.mode == 'validation'
        run: |
          echo "Checking for expected build outputs..."

          DMG_FILE=$(find apps/desktop/src-tauri/target -name "*.dmg" 2>/dev/null | head -1)
          TAR_FILE=$(find apps/desktop/src-tauri/target -name "*.app.tar.gz" 2>/dev/null | head -1)

          if [ -z "$DMG_FILE" ]; then
            echo "Error: DMG file not found"
            exit 1
          fi
          echo "DMG: $DMG_FILE"

          if [ -z "$TAR_FILE" ]; then
            echo "Error: .app.tar.gz not found"
            exit 1
          fi
          echo "TAR: $TAR_FILE"

          echo "Build validation passed"

      - name: Collect and normalize assets
        if: steps.build-mode.outputs.mode == 'release'
        run: |
          node scripts/release/collect-assets.cjs \
            --version "${{ steps.build-mode.outputs.version }}" \
            --platform macos \
            --output release-assets/

      - name: Upload artifacts
        if: steps.build-mode.outputs.mode == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: release-assets/
          retention-days: 7
